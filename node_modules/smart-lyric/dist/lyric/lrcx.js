"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringify = exports.parse = exports.encrypt = exports.decrypt = void 0;
const zlib_1 = __importDefault(require("zlib"));
const iconv_lite_1 = __importDefault(require("iconv-lite"));
const declare_1 = require("./declare");
const common_1 = require("./common");
const KUWO_LYRIC_KEY = Buffer.from('yeelion');
//加密、解密
function cryptLRCX(buffer) {
    for (let i = 0; i < buffer.length; ++i) {
        buffer[i] ^= KUWO_LYRIC_KEY[i % KUWO_LYRIC_KEY.byteLength];
    }
    return buffer;
}
/**
 * 解密LRCX歌词
 * @param buffer 歌词内容
 * @returns 解密后的歌词，解密失败返回null
 */
function decrypt(buffer) {
    try {
        //解压
        const b64Str = zlib_1.default.inflateSync(buffer).toString();
        //取得内容
        const content = Buffer.from(b64Str, 'base64');
        //解密
        cryptLRCX(content);
        //return
        return iconv_lite_1.default.decode(content, 'gb18030');
        //完成
    }
    catch (err) {
        return null;
    }
}
exports.decrypt = decrypt;
/**
 * 编码歌词
 * @param content 歌词的文本内容
 */
function encrypt(content) {
    //编码处理
    const codeData = iconv_lite_1.default.encode(content.toString(), 'gb18030');
    //加密
    cryptLRCX(codeData);
    //转为base64
    const b64Str = codeData.toString('base64');
    //压缩
    return zlib_1.default.deflateSync(b64Str);
}
exports.encrypt = encrypt;
/**
 * 解析LRCX歌词
 * @param lrcxText LRCX歌词文本内容
 */
function parse(lrcxText) {
    //结果
    const result = { type: declare_1.LyricType.KARA, content: [] };
    //逐行处理
    lrcxText.split(/\r?\n/).forEach(line => {
        line = line.trim();
        const match = line.match(/^\[(\d+):(\d+).(\d+)\]/);
        //需要读取到[kuwo:xxx]后才能解析
        if (match && result.ext?.kuwo) {
            const m = parseInt(match[1]);
            const s = parseInt(match[2]);
            const ms = parseInt(match[3]);
            line = line.substring(match[0].length);
            //得到kuwo标志中的8进制值
            const kuwo = parseInt(result.ext.kuwo, 8);
            const k1 = parseInt(kuwo / 10);
            const k2 = parseInt(kuwo % 10);
            //解析歌词文字
            const lyricLine = {
                start: (m * 60 * 1000) + (s * 1000) + ms,
                duration: 0,
                content: []
            };
            while (line.length) {
                const match = line.match(/<(\d+),([-\d]+)>([^<]+)/);
                if (!match)
                    break;
                const v1 = parseInt(match[1]);
                const v2 = parseInt(match[2]);
                line = line.substring(match[0].length);
                const start = (v1 + v2) / (k1 * 2);
                const dur = (v1 - v2) / (k2 * 2);
                lyricLine.content.push({ start, duration: dur, content: match[3] });
            }
            if (lyricLine.content.length) {
                //计算一下行持续时间
                const last = lyricLine.content[lyricLine.content.length - 1];
                lyricLine.duration = last.start + last.duration;
                result.content.push(lyricLine);
            }
        }
        else
            (0, common_1.parseLyricTag)(result, line);
    });
    return result;
}
exports.parse = parse;
/**
 * 将LRCX歌词转换为文本
 *
 * _注意：如果没有设置lyric.ext.kuwo,系统会自动生成一个_
 *
 * @param lyric 歌词(只能是卡拉OK歌词)
 */
function stringify(lyric) {
    if (lyric.type != declare_1.LyricType.KARA)
        throw new Error(`lrc cannot stringify to lrcx`);
    //处理一下歌词信息
    lyric = {
        ...lyric,
        ext: {
            ...lyric.ext ?? {},
            kuwo: lyric.ext?.kuwo ?? (() => {
                while (true) {
                    const k = parseInt(Math.random() * (0o77 - 10)) + 10;
                    if (k % 10 != 0)
                        return '0' + k.toString(8);
                }
            })(),
        }
    };
    const buffer = [...(0, common_1.genLyricTag)(lyric, { skipEmpty: false })];
    //取得kuwo标记
    const kuwo = parseInt(lyric.ext?.kuwo, 8);
    const k1 = parseInt(kuwo / 10);
    const k2 = parseInt(kuwo % 10);
    lyric.content.forEach(line => {
        if (typeof line.content === 'string')
            return;
        const m = parseInt(line.start / 1000 / 60).toString().padStart(2, '0');
        const s = parseInt(line.start / 1000 % 60).toString().padStart(2, '0');
        const ms = parseInt(line.start % 1000).toString().padStart(3, '0');
        const text = line.content.map(word => {
            const v1 = word.start * (k1 * 2);
            const v2 = word.duration * (k2 * 2);
            //求解方程:
            // a + b = v1
            // a - b = v2
            const a = parseInt((v1 + v2) / 2);
            const b = parseInt((v1 - v2) / 2);
            //完成
            return `<${a},${b}>${word.content}`;
        }).join('');
        buffer.push(`[${m}:${s}.${ms}]${text}`);
    });
    return buffer.join('\n');
}
exports.stringify = stringify;
