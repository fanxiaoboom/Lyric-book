"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.des = exports.DesType = void 0;
const MASK32 = 0xFFFFFFFF;
/*定义一个密钥置换的映射*/
const DES_TRANSFORM = Buffer.from([
    57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18,
    10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,
    63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22,
    14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4,
]);
/*定义用于计算子密钥的旋转次数*/
const DES_ROTATIONS = Buffer.from([1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]);
/*定义用于子密钥置换选择的映射*/
const DES_PERMUTED = Buffer.from([
    14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10,
    23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,
    41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
    44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32,
]);
/*定义用于数据块初始化转换的映射*/
const DES_INITIAL = Buffer.from([
    58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
    62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
    57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
    61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7
]);
/*数据块的最终置换*/
const DES_FINAL = Buffer.from([
    40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31,
    38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29,
    36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27,
    34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25
]);
/*数据块的P盒置换*/
const DES_PBOX = Buffer.from([
    16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10,
    2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25,
]);
/*定义用于数据块扩展转换的映射*/
const DES_EXPANSION = Buffer.from([
    32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9,
    8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
    16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
    24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1,
]);
/*定义用于数据块中S盒转换的S盒表*/
const DES_SBOX = Buffer.from([
    0x0E, 0x00, 0x04, 0x0F, 0x0D, 0x07, 0x01, 0x04, 0x02, 0x0E, 0x0F, 0x02, 0x0B, 0x0D, 0x08, 0x01,
    0x03, 0x0A, 0x0A, 0x06, 0x06, 0x0C, 0x0C, 0x0B, 0x05, 0x09, 0x09, 0x05, 0x00, 0x03, 0x07, 0x08,
    0x04, 0x0F, 0x01, 0x0C, 0x0E, 0x08, 0x08, 0x02, 0x0D, 0x04, 0x06, 0x09, 0x02, 0x01, 0x0B, 0x07,
    0x0F, 0x05, 0x0C, 0x0B, 0x09, 0x03, 0x07, 0x0E, 0x03, 0x0A, 0x0A, 0x00, 0x05, 0x06, 0x00, 0x0D,
    0x0F, 0x03, 0x01, 0x0D, 0x08, 0x04, 0x0E, 0x07, 0x06, 0x0F, 0x0B, 0x02, 0x03, 0x08, 0x04, 0x0F,
    0x09, 0x0C, 0x07, 0x00, 0x02, 0x01, 0x0D, 0x0A, 0x0C, 0x06, 0x00, 0x09, 0x05, 0x0B, 0x0A, 0x05,
    0x00, 0x0D, 0x0E, 0x08, 0x07, 0x0A, 0x0B, 0x01, 0x0A, 0x03, 0x04, 0x0F, 0x0D, 0x04, 0x01, 0x02,
    0x05, 0x0B, 0x08, 0x06, 0x0C, 0x07, 0x06, 0x0C, 0x09, 0x00, 0x03, 0x05, 0x02, 0x0E, 0x0F, 0x09,
    0x0A, 0x0D, 0x00, 0x07, 0x09, 0x00, 0x0E, 0x09, 0x06, 0x03, 0x03, 0x04, 0x0F, 0x06, 0x05, 0x0A,
    0x01, 0x02, 0x0D, 0x08, 0x0C, 0x05, 0x07, 0x0E, 0x0B, 0x0C, 0x04, 0x0B, 0x02, 0x0F, 0x08, 0x01,
    0x0D, 0x01, 0x06, 0x0A, 0x04, 0x0D, 0x09, 0x00, 0x08, 0x06, 0x0F, 0x09, 0x03, 0x08, 0x00, 0x07,
    0x0B, 0x04, 0x01, 0x0F, 0x02, 0x0E, 0x0C, 0x03, 0x05, 0x0B, 0x0A, 0x05, 0x0E, 0x02, 0x07, 0x0C,
    0x07, 0x0D, 0x0D, 0x08, 0x0E, 0x0B, 0x03, 0x05, 0x00, 0x06, 0x06, 0x0F, 0x09, 0x00, 0x0A, 0x03,
    0x01, 0x04, 0x02, 0x07, 0x08, 0x02, 0x05, 0x0C, 0x0B, 0x01, 0x0C, 0x0A, 0x04, 0x0E, 0x0F, 0x09,
    0x0A, 0x03, 0x06, 0x0F, 0x09, 0x00, 0x00, 0x06, 0x0C, 0x0A, 0x0B, 0x0A, 0x07, 0x0D, 0x0D, 0x08,
    0x0F, 0x09, 0x01, 0x04, 0x03, 0x05, 0x0E, 0x0B, 0x05, 0x0C, 0x02, 0x07, 0x08, 0x02, 0x04, 0x0E,
    0x02, 0x0E, 0x0C, 0x0B, 0x04, 0x02, 0x01, 0x0C, 0x07, 0x04, 0x0A, 0x07, 0x0B, 0x0D, 0x06, 0x01,
    0x08, 0x05, 0x05, 0x00, 0x03, 0x0F, 0x0F, 0x0A, 0x0D, 0x03, 0x00, 0x09, 0x0E, 0x08, 0x09, 0x06,
    0x04, 0x0B, 0x02, 0x08, 0x01, 0x0C, 0x0B, 0x07, 0x0A, 0x01, 0x0D, 0x0E, 0x07, 0x02, 0x08, 0x0D,
    0x0F, 0x06, 0x09, 0x0F, 0x0C, 0x00, 0x05, 0x09, 0x06, 0x0A, 0x03, 0x04, 0x00, 0x05, 0x0E, 0x03,
    0x0C, 0x0A, 0x01, 0x0F, 0x0A, 0x04, 0x0F, 0x02, 0x09, 0x07, 0x02, 0x0C, 0x06, 0x09, 0x08, 0x05,
    0x00, 0x06, 0x0D, 0x01, 0x03, 0x0D, 0x04, 0x0E, 0x0E, 0x00, 0x07, 0x0B, 0x05, 0x03, 0x0B, 0x08,
    0x09, 0x04, 0x0E, 0x03, 0x0F, 0x02, 0x05, 0x0C, 0x02, 0x09, 0x08, 0x05, 0x0C, 0x0F, 0x03, 0x0A,
    0x07, 0x0B, 0x00, 0x0E, 0x04, 0x01, 0x0A, 0x07, 0x01, 0x06, 0x0D, 0x00, 0x0B, 0x08, 0x06, 0x0D,
    0x04, 0x0D, 0x0B, 0x00, 0x02, 0x0B, 0x0E, 0x07, 0x0F, 0x04, 0x00, 0x09, 0x08, 0x01, 0x0D, 0x0A,
    0x03, 0x0E, 0x0C, 0x03, 0x09, 0x05, 0x07, 0x0C, 0x05, 0x02, 0x0A, 0x0F, 0x06, 0x08, 0x01, 0x06,
    0x01, 0x06, 0x04, 0x0B, 0x0B, 0x0D, 0x0D, 0x08, 0x0C, 0x01, 0x03, 0x04, 0x07, 0x0A, 0x0E, 0x07,
    0x0A, 0x09, 0x0F, 0x05, 0x06, 0x00, 0x08, 0x0F, 0x00, 0x0E, 0x05, 0x02, 0x09, 0x03, 0x02, 0x0C,
    0x0D, 0x01, 0x02, 0x0F, 0x08, 0x0D, 0x04, 0x08, 0x06, 0x0A, 0x0F, 0x03, 0x0B, 0x07, 0x01, 0x04,
    0x0A, 0x0C, 0x09, 0x05, 0x03, 0x06, 0x0E, 0x0B, 0x05, 0x00, 0x00, 0x0E, 0x0C, 0x09, 0x07, 0x02,
    0x07, 0x02, 0x0B, 0x01, 0x04, 0x0E, 0x01, 0x07, 0x09, 0x04, 0x0C, 0x0A, 0x0E, 0x08, 0x02, 0x0D,
    0x00, 0x0F, 0x06, 0x0C, 0x0A, 0x09, 0x0D, 0x00, 0x0F, 0x03, 0x03, 0x05, 0x05, 0x06, 0x08, 0x0B,
]);
/* 位掩码 */
const BITOF = (n) => (1 << n) >>> 0;
const DES_BITMAP = [
    BITOF(31), BITOF(30), BITOF(29), BITOF(28), BITOF(27), BITOF(26), BITOF(25), BITOF(24),
    BITOF(23), BITOF(22), BITOF(21), BITOF(20), BITOF(19), BITOF(18), BITOF(17), BITOF(16),
    BITOF(15), BITOF(14), BITOF(13), BITOF(12), BITOF(11), BITOF(10), BITOF(9), BITOF(8),
    BITOF(7), BITOF(6), BITOF(5), BITOF(4), BITOF(3), BITOF(2), BITOF(1), BITOF(0),
    BITOF(31), BITOF(30), BITOF(29), BITOF(28), BITOF(27), BITOF(26), BITOF(25), BITOF(24),
    BITOF(23), BITOF(22), BITOF(21), BITOF(20), BITOF(19), BITOF(18), BITOF(17), BITOF(16),
    BITOF(15), BITOF(14), BITOF(13), BITOF(12), BITOF(11), BITOF(10), BITOF(9), BITOF(8),
    BITOF(7), BITOF(6), BITOF(5), BITOF(4), BITOF(3), BITOF(2), BITOF(1), BITOF(0),
];
const DES_ROTATION_MASK = [0, 0x80000000, 0xc0000000];
//16个子密钥
const subKeys = [];
const tempKey = { low: 0, high: 0 };
/** DES方法 */
var DesType;
(function (DesType) {
    /** 加密 */
    DesType[DesType["Encode"] = 0] = "Encode";
    /** 解密 */
    DesType[DesType["Decode"] = 1] = "Decode";
})(DesType = exports.DesType || (exports.DesType = {}));
/** 将数字转换为无符号32位整数 */
function uint32(v) {
    return v >>> 0;
}
/**
 * 生成子密钥
 * @param index 子密钥位置
 */
function createSubKey(index) {
    const sub = subKeys[index];
    const rcnt = DES_ROTATIONS[index];
    let v6 = tempKey.low & DES_ROTATION_MASK[rcnt];
    let v7 = tempKey.high & DES_ROTATION_MASK[rcnt];
    if (rcnt == 1) {
        v6 = v6 >>> 27;
        v7 = v7 >>> 27;
    }
    else {
        v6 = v6 >>> 26;
        v7 = v7 >>> 26;
    }
    tempKey.low = uint32(tempKey.low << rcnt) & MASK32;
    tempKey.high = uint32(tempKey.high << rcnt) & MASK32;
    tempKey.low = uint32(tempKey.low | uint32(v6 & 0xFFFFFFF0));
    tempKey.high = uint32(tempKey.high | uint32(v7 & 0xFFFFFFF0));
    for (let i = 0; i < 48; ++i) {
        const v10 = DES_PERMUTED[i];
        if (i >= 24) {
            if (DES_BITMAP[v10 - 29 + 1] & tempKey.high)
                sub.high = uint32(sub.high | DES_BITMAP[i - 24]);
        }
        else if (tempKey.low & DES_BITMAP[v10 - 1])
            sub.low = uint32(sub.low | DES_BITMAP[i]);
    }
}
/**
 * 初始化子密钥
 * @param key 密钥
 */
function makeFirstKey(key) {
    const first = { low: key.readUint32LE(0), high: key.readUint32LE(4) };
    tempKey.high = tempKey.low = 0;
    //初始化自密钥
    if (!subKeys.length) {
        for (let i = 0; i < 16; ++i)
            subKeys.push({ low: 0, high: 0 });
    }
    else
        subKeys.forEach(k => k.high = k.low = 0);
    // 将key转置压缩为56位
    for (let i = 0; i < 28; ++i) {
        let item = DES_TRANSFORM[i];
        let got = (item <= 32 ? first.low : first.high) & DES_BITMAP[item - 1]; //置换映射表从1开始的，这里-1
        if (got)
            tempKey.low = uint32(tempKey.low | DES_BITMAP[i]);
        item = DES_TRANSFORM[i + 28];
        got = (item <= 32 ? first.low : first.high) & DES_BITMAP[item - 1];
        if (got)
            tempKey.high = uint32(tempKey.high | DES_BITMAP[i]);
    }
    //计算16个子密钥
    for (let i = 0; i < 16; ++i)
        createSubKey(i);
}
/**
 * 数据迭代
 * @param data 要迭代的数据
 * @param subKey 子密钥
 */
function makeData(data, subKey) {
    let low = 0;
    let high = 0;
    const tempHigh = data.high;
    for (let i = 0; i < 48; ++i) {
        const mask = DES_BITMAP[DES_EXPANSION[i] - 1];
        if (i >= 24) {
            if (mask & tempHigh)
                high = uint32(high | DES_BITMAP[i - 24]);
        }
        else if (mask & tempHigh)
            low = uint32(low | DES_BITMAP[i]);
    }
    low = uint32(low ^ subKey.low);
    high = uint32(high ^ subKey.high);
    const buffer = Buffer.from([
        (low >>> 26) & 0x3F,
        (low >>> 20) & 0x3F,
        (low >>> 14) & 0x3f,
        (low >>> 8) & 0x3f,
        (high >>> 26) & 0x3F,
        (high >>> 20) & 0x3F,
        (high >>> 14) & 0x3f,
        (high >>> 8) & 0x3f,
    ]);
    data.high = 0;
    let byte_index = 0;
    for (let i = 0; i < 448; i += 64, ++byte_index) {
        data.high = uint32(data.high | DES_SBOX[buffer[byte_index] + i]) * 16;
    }
    data.high = uint32(data.high | DES_SBOX[64 * byte_index + buffer[byte_index]]);
    let tmp = 0;
    for (let i = 0; i < 32; ++i) {
        if (data.high & DES_BITMAP[DES_PBOX[i] - 1])
            tmp = uint32(tmp | DES_BITMAP[i]);
    }
    data.high = uint32(tmp ^ data.low);
    data.low = tempHigh;
}
/**
 * 处理数据
 * @param type 操作类型
 * @param data 操作的单个64位数据
 */
function handleData(type, data) {
    let mask_ok;
    let low = 0;
    let high = 0;
    for (let i = 0; i < 64; ++i) {
        const v5 = DES_INITIAL[i];
        if (i >= 32) {
            if (v5 <= 32)
                mask_ok = uint32(DES_BITMAP[v5 - 1] & data.low);
            else
                mask_ok = uint32(DES_BITMAP[v5 - 1] & data.high);
            if (mask_ok)
                high = uint32(high | DES_BITMAP[i]);
        }
        else {
            if (v5 <= 32)
                mask_ok = uint32(DES_BITMAP[v5 - 1] & data.low);
            else
                mask_ok = uint32(DES_BITMAP[v5 - 1] & data.high);
            if (mask_ok)
                low = uint32(low | DES_BITMAP[i]);
        }
    }
    data.low = low;
    data.high = high;
    // 16轮迭代
    if (type == DesType.Encode) {
        for (let i = 0; i < 16; ++i)
            makeData(data, subKeys[i]);
    }
    if (type == DesType.Decode) {
        for (let i = 15; i >= 0; --i)
            makeData(data, subKeys[i]);
    }
    const tmp = data.low;
    data.low = data.high;
    data.high = tmp;
    low = 0;
    high = 0;
    for (let i = 0; i < 64; ++i) {
        if (i >= 32) {
            if (DES_FINAL[i] <= 32)
                mask_ok = uint32(DES_BITMAP[DES_FINAL[i] - 1] & data.low);
            else
                mask_ok = uint32(data.high & DES_BITMAP[DES_FINAL[i] - 1]);
            if (mask_ok)
                high = uint32(high | DES_BITMAP[i]);
        }
        else {
            if (DES_FINAL[i] <= 32)
                mask_ok = uint32(DES_BITMAP[DES_FINAL[i] - 1] & data.low);
            else
                mask_ok = uint32(data.high & DES_BITMAP[DES_FINAL[i] - 1]);
            if (mask_ok)
                low = uint32(low | DES_BITMAP[i]);
        }
    }
    data.low = low;
    data.high = high;
}
/**
 * 进行des加密/解密，内容存回src
 * @param src 原始数据
 * @param key 密码
 * @param type 加密、解密
 */
function des(src, key, type) {
    makeFirstKey(key);
    for (let i = 0; i < src.byteLength; i += 8) {
        const data = { low: src.readUint32LE(i), high: src.readUint32LE(i + 4) };
        handleData(type, data);
        src.writeUint32LE(data.low, i);
        src.writeUint32LE(data.high, i + 4);
    }
}
exports.des = des;
